**子集问题**是集合论中最为基础的问题，如果让我们写出一个集合的所有子集，我们初中就可以轻松地写出来，这里只是用程序设计语言将其表达出来。每当我遇到这类问题时，我的做法是**先考虑我是如何手工解决这个问题的，然后试着将解题过程用程序设计语言表示出来**。   
   
下面是我写出一个集合的所有子集的过程：
   
以集合 {1, 2, 3, 4}为例：  
   
    {}   
    
    1   
    2   
    3   
    4    
    
    1 2     
    1 3     2 3
    1 4     2 4     3 4    
    
    1 2 3     
    1 2 4     1 3 4     2 3 4    
    
    1 2 3 4    
我不知道大家是怎么写的，我一直是这样求子集的。如果你也是这样写的，可以想一下这里面的思路。我简单总结了一下：  
   
1. 从空集、包含1个元素的子集、包含2个元素的子集...直到该集合
2. 对于每个固定元素个数的集合，每次从高位到低位（从右向左），每一位从小到大，高位达到最大值后，最近的低位增加，高位从小到大继续（注意高位的数永远大于低位）...重复这一过程直到最低位达到其可以达到的最大值   
   
***
看了我的总结你可能还是一头雾水，下面具体用程序说明一下：   
   
比如我要求集合{1, 2, 3, 4, 5}包含3个元素的子集，第一个子集肯定是{1, 2, 3},即最前面的3个数，这样对于cnt个元素的子集，第一个集合可以这样求得：   
```cpp
for (int i = 0; i < cnt; ++i)
    vec_helper.push_back(nums[i]);    // vec_helper最为一个辅助集合用来记录每次求得的集合
```
接下来我们判断当前集合是否存在下一个集合，比如集合{1, 2, 3}下一个集合是{1, 2, 4}, 而集合{3, 4, 5}则是包含3个元素的最后一个子集，这个判断过程用下面的片段实现：   
```cpp
int next(vector<int> &vec1, vector<int>& vec2) {
    for (int i = vec1.size()-1, j = vec2.size()-1; i >= 0; --i, --j)
        if (vec1[i] < vec2[j]) return i;
    return -1;
}
```
vec1表示当前求得的集合（如{3, 4, 5})，vec2表示题目给定的集合（{1, 2, 3, 4, 5}）, 从当前集合的高位开始，发现每一位都达到了该位可能的最大值，所以返回-1，之所以用-1来表示不存在下一个集合是因为这个函数在存在下一个集合时需要返回可以增加元素值的位置，比如如果当前求得的集合是{2, 3, 5},从高位开始检查，发现3没有达到第二位可以达到的最大值即4，所以返回1（第二位3的位置）   
   
假如存在下一个集合，如上面的{2, 3, 5}，则先找到改变位（第二位即3）的下一个值，
```cpp
for (int i = 0; i < nums.size(); ++i)
    if (vec_helper[pos] < nums[i]) {
      ix = i;
      break;
}
```
然后将改变位变为其下一个值，注意后面的值要从小到大取，即下一个集合为{2, 4, 5}，最高位可取的最小值为5（高位永远大于低位）
```cpp
for (int i = pos; i < vec_helper.size(); ++i, ++ix)
    vec_helper[i] = nums[ix];
```
这样就求得了下一个集合。
    
对于每一个固定大小的集合，重复上面过程求出所有的子集。   
***
[pezy](https://github.com/pezy/LeetCode/tree/master/063.%20Subsets)给出了一种利用二进制的解法，有兴趣可以[看下](https://github.com/pezy/LeetCode/tree/master/063.%20Subsets)。
