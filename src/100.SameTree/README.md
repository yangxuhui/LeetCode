虽是一道Easy难度的题，还是花了我不少时间（以前真心没写过树和图的代码）。   
   
最初我的想法是中序遍历+先序遍历/后序遍历=唯一确定一棵树，这里有一个问题，比如树的所有节点的值都为1，显然无论哪种方式遍历，结果序列都是一样的，不能用来确定两棵树是否相同。（想想也是，一道Easy难度的题要把两种遍历方式都写一遍也不大可能）  
   
接下来我能想到的方法就是**层次遍历**了，这显然是一个可行的方法，从上到下，从左到右比较每个节点。当然，实现起来代码还是有些冗长，会用到**队列**。   
   
***
看了一下[pezy](https://github.com/pezy/LeetCode/tree/master/003.%20Same%20Tree)的解法，果然被虐的无地自容（“花了不到3分钟”--果然**水平菜要承认，被虐也要学习**）。他用递归解决，不仅好理解，而且递归果然是简洁。思路很简单：从根节点开始，递归地比较左右子树。
