还是因为看过《算法导论》对一次买卖的分析，我做这道题时又从差价入手进行分析：  
   
|  天  |0|1|2|3|4|5|6|7|8| 
| ---- | --- | ---- | ---- | ---- | ---- | ---- | ---- |  --- | ---- |
|每日价格|4|3|5|7|9|4|3|6|2|    
|价格变化| |-1|2|2|2|-5|-1|3|-4|    
   
因为我们可以进行任意次数的买卖，因此，我们要做的就是将所有差价为正数的钱挣到手，所以，我们从第一天开始（若只有第0天，即prices.size() == 1，收益为0），如果比前一天价格高，我们就收益差价，遍历完成时，收益即最大收益。    
    
```cpp
for (int i = 1; i < prices.size(); ++i)
  if (prices[i] > prices[i-1])
    profit += (prices[i] - prices[i-1]);
```   
   
***
看了一下[pezy](https://github.com/pezy/LeetCode/tree/master/005.%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20II)对这道题的分析，理解更加深刻了，他进过分析将题目意思转化为**找到所有有序子序列，计算各系列首尾差值，返回差值之和**。虽然看似思路不同，但是你会发现解题步骤是一样的。
