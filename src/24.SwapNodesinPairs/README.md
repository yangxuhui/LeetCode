这道题第一个关键的地方是：交换两个结点，不仅仅是这两个结点参与，还与这两个结点前后结点有关。**这两个结点交换之后还要与前后结点保持链接**。  
***  
  
我的解法附设了一个辅助结点保存交换结点之前的节点信息，以保持链表链接，但是由于头结点之前没有结点，所以需要增加逻辑判断是否操作的是头结点；还有一个麻烦的地方在于，由于每次需要保存两个交换结点的信息，所以当结点个数为偶数时，最后一次迭代会出现第一结点为NULL，同时第二个结点为第一个结点的下一个结点，从而出现NULL->next导致Runtime Error。因此还要增加一个逻辑判断来处理这种情况。  
***  
  
[pezy](https://github.com/pezy/LeetCode/tree/master/023.%20Swap%20Nodes%20in%20Pairs)的解法在头结点之前设置了辅助结点，一
方面解决了头结点之前没有结点的情形，另一方面保存的节点信息变为**交换结点之前的节点和第一个交换结点的信息**，这就避免了第二种情况。可以看出，在头结点之前设置辅助结点的做法减少了两种情况的逻辑判断，使得整个代码更加简洁，同时，LeetCode的执行结果表明这样使得运行时间也减少了。  
***  
  
pezy的解法展示了这道题第二个关键点：可以通过**在头结点之前设置辅助的代理结点**来使算法处理逻辑一致。当算法中头结点需要额外的处理时，这种思路一般可以避免这种额外的处理而使算法处理逻辑一致。
